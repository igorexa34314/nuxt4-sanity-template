import { defineNuxtModule, useNitro } from 'nuxt/kit';

export default defineNuxtModule({
  meta: {
    name: 'configure-service-worker',
  },
  setup(_, nuxt) {
    const allowListRoutes = new Set<string>();
    const sanityConfig = nuxt.options.runtimeConfig.public.sanity;

    nuxt.hook('prerender:routes', ({ routes }) => {
      for (const route of Array.from(routes)) {
        allowListRoutes.add(route);
      }
    });

    // Vercel can't handle 200.html and 404.html pages generated by nuxt
    // So we added rewrite to vercel.json
    // NOTE: We could exclude 200.html in any case because we don't have dynamic routes
    // https://github.com/nuxt/nuxt/issues/18683#issuecomment-1553076610
    //
    nuxt.hook('ready', () => {
      const nitro = useNitro();
      const excludedRoutes = new Set(['/200.html' /* '/404.html' */]);

      nitro.hooks.hook('prerender:generate', route => {
        const isVercel =
          import.meta.env.VERCEL || nitro.options.preset === 'vercel-static';
        if (isVercel && excludedRoutes.has(route.route)) {
          route.skip = true;
        }
      });
    });

    nuxt.hook('pwa:beforeBuildServiceWorker', options => {
      if (options.strategies !== 'injectManifest') {
        // Increase max file size because we have large images in /public folder
        options.workbox.maximumFileSizeToCacheInBytes = 4 * 1024 * 1024;

        options.workbox.navigateFallbackAllowlist ??= [];
        options.workbox.runtimeCaching ??= [];
        const {
          workbox: { navigateFallbackAllowlist, runtimeCaching },
          base,
        } = options;

        const sanityImageCDN = 'https://cdn.sanity.io/images';

        runtimeCaching.push({
          urlPattern: new RegExp(
            `^${sanityImageCDN}/${sanityConfig.projectId}/${sanityConfig.dataset}/.*\\.(webp|png|jpe?g|svg|gif|avif)`
          ),
          handler: 'CacheFirst',
          options: {
            cacheName: 'images-CDN',
            matchOptions: {
              ignoreSearch: false,
              ignoreVary: true,
            },
            cacheableResponse: { statuses: [0, 200] },
            rangeRequests: true,
            plugins: [
              {
                // This plugin will only igonore params that are not related to sanity image URL
                cacheKeyWillBeUsed: async ({ request }) => {
                  const url = new URL(request.url);
                  const sanityImageCDNParams = [
                    'w',
                    'h',
                    'fm',
                    'dl',
                    'blur',
                    'sharp',
                    'invert',
                    'or',
                    'min-h',
                    'max-h',
                    'min-w',
                    'max-w',
                    'q',
                    'fit',
                    'crop',
                    'sat',
                    'auto',
                    'dpr',
                    'pad',
                    'frame',
                  ];

                  // Keep only specific params
                  [...url.searchParams.keys()].forEach(key => {
                    if (!sanityImageCDNParams.includes(key)) {
                      url.searchParams.delete(key);
                    }
                  });

                  return new Request(url.toString(), {
                    method: request.method,
                    headers: request.headers,
                  });
                },
              },
            ],
          },
        });

        // Redirect to 404 when page is not exist
        runtimeCaching.push({
          urlPattern: ({ request, sameOrigin }) => {
            return sameOrigin && request.mode === 'navigate';
          },
          handler: 'NetworkOnly',
          options: {
            plugins: [
              {
                /* this callback will be called when the fetch call fails */
                handlerDidError: async () => Response.redirect('404', 302),
                /* this callback will prevent caching the response */
                cacheWillUpdate: async () => null,
              },
            ],
          },
        });
        const existingAllowList = new Set(
          navigateFallbackAllowlist.map(r => r.source)
        );
        for (const route of allowListRoutes) {
          const regex = new RegExp(
            route === options.base
              ? `^${escapeStringRegexp(base)}$`
              : `^${escapeStringRegexp(route.startsWith(base) ? route : `${base}${route}`)}$`
          );
          if (existingAllowList.has(regex.source)) {
            continue;
          }

          navigateFallbackAllowlist.push(regex);
        }
      }
    });
  },
});

function escapeStringRegexp(value: string) {
  // Escape characters with special meaning either inside or outside character sets.
  // Use a simple backslash escape when it’s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
  return value.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
